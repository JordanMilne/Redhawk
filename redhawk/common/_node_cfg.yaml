# YAML markup for generating the node classes.
# Each node must be a subclass of Node (default)
# The output classes generated are in alphabetical order.
#
# The following attributes are allowed (the sexp attribute is compulsory, all
# others optional). The defaults are as show in the square brackets.)
#   * sexp              (a yaml list)
#   * super [Node]      (a single class to inherit from)
#   * docstring ['']    (a single line doc string)
#   * args ['']         (a cs-list)
#   * children ['']     (a cs-list)
#   * xml ['']          (a yaml list)
#   * json ['']         (a yaml list)
#   * dot ['']          (a yaml list)
#   * optargs ['']      (a cs-list)
#
# A cs-list is a comma+space separated list like as follows
#   this, is, a, comma, separated, list
# This has been introduced only to make entry easier.


Module:
  docstring : "Represents a file or module."
  args: filename, children
  children: '*children'
  sexp: ["define-module", filename, children]
  xml: ["define-module", filename]

Constant:
  docstring: "Represents A Constant."
  args: position, value
  optargs: type
  sexp : ["constant", value, [_type, type]]
  children:

Return:
  docstring: "Represents a Return Statement."
  args: position, return_expression
  children: return_expression
  sexp: ["return", return_expression]

Yield:
  docstring: "Yield Statement"
  args: position, yield_expression
  children: yield_expression
  sexp: ["yield", yield_expression]

DeclareSymbol:
  docstring: "Declare a symbol (like an ENUM, or like a lisp symbol)."
  args: position, name
  optargs: value
  sexp: ["declare-constant", name,  [_value, value]]
  children: value

DefineVariable:
  docstring: "A Variable Definition Node."
  args: position, name
  optargs: init, type, quals, storage
  sexp: ["define-variable", name, [_init, init], [_type, type], [_quals, quals], [_storage, storage]]
  children:

FunctionArguments:
  docstring: "Function Arguments."
  args: position, arguments
  optargs: var_arguments, kwd_arguments
  sexp: ['*arguments', [_var_arguments, var_arguments], [_kwd_arguments, kwd_arguments]]
  children: arguments, var_arguments, kwd_arguments
  
DeclareFunction:
  docstring: "A Function Declaration Node."
  args: position, name, arguments
  optargs: return_type, storage, quals
  children: arguments
  sexp: ["declare-function", name, arguments, [_return_type, return_type], [_quals, quals], [_storage, storage]]

DefineFunction:
  docstring: "A Function Definition Node."
  args: position, name, arguments, body
  optargs: return_type, storage, quals
  children: arguments, body
  sexp: ["define-function", name, arguments, body, [_return_type, return_type], [_quals, quals], [_storage, storage]]

Compound:
  docstring: "A compond list of items"
  args: position, compound_items
  children: '*compound_items'
  sexp: ['compound', '*compound_items']

Expression:
  docstring: "An expression Node."
  args: position, operator, children
  children: '*children'
  sexp: ['`ALLOWED_OPERATORS[self.operator][0]`', '*children']

ReferVariable:
  docstring: "A variable reference."
  args: position, name
  sexp: ['*name']
  children:

Assignment:
  docstring: "An assignment `lvalue = rvalue`"
  args: position, lvalue, rvalue
  sexp: ["assign", lvalue, rvalue]
  children: lvalue, rvalue

CallFunction:
  docstring: "A function call. (position, function, arguments), where the function itself is a tree (with a refer variable node)."
  args: position, function, arguments
  sexp: ["apply", function, arguments]
  children: function, arguments

Structure:
  docstring: "A structure type"
  args: position, name, members
  optargs: storage, quals
  sexp: ["define-structure", name, members, [_storage, storage], [_quals, quals]]
  children: '*members'

IfElse:
  docstring: "An If Else Node."
  args: position, condition, if_true
  optargs: if_false
  sexp: ["if", condition, if_true, if_false]
  children: condition, if_true, if_false

For:
  docstring: "A For Loop."
  args: position, init, condition, step, body
  sexp: ["for", [init, condition, step], body]
  children: init, condition, step, body

While:
  docstring: "Represents a While Loop."
  args: position, condition, body
  optargs: do_while
  sexp: ["while", [_do_while, 'true'], condition, body]
  children: condition, body

Switch:
  docstring: "A Swith Case Statement"
  args: position, switch_on, body
  sexp: ["switch", switch_on, body]
  children: switch_on, body

CaseDefault:
  docstring: "A case or default statement."
  args: position
  optargs: condition
  sexp: ["default-or-case", [_condition, 'case', condition]]
  children: condition

DefineType:
  docstring: "A Type Definition."
  args: position, name, type
  sexp: ["define-type", name, type]
  children: type

List:
  docstring: "A List."
  args: position, values
  sexp: ['*values']
  children: '*values'

Tuple:
  docstring: "A Tuple."
  args: position, members 
  sexp: ['*members']
  children: '*members'
 
Enumerator:
  docstring: "An Enumerator."
  args: position, name, values
  sexp: ["define-enumerator", name, values]
  children: '*values'

Statement:
  docstring: "An Miscellaneous Statement Node."
  args: position, name, children
  children: '*children'
  sexp: ['`ALLOWED_STATEMENTS[self.name][0]`', '*children']

Goto:
  docstring: "The Goto construct. Considered Harmful, yea?"
  args: position, location
  children:
  sexp: ['goto', location]

SourceLabel:
  docstring: "A label in the source. Like the Goto labels."
  args: position, name, statements
  children: statements
  sexp: ['label', name, statements]

Union:
  docstring: "A union type"
  args: position, name, members
  sexp: ["define-union", name, members]
  children: '*members'

Comprehension:
  docstring: "A list (or set, dict, ..) comprehension. Python/Haskell. Type is one of 'set' or 'list' or 'generator' or 'dict'"
  args: position, expr, generators, type
  sexp: ["comprehension", type, expr, '*generators']
  children: expr, generators

Generator:
  docstring: "The generator of a comprehension `for x in .. if ..` Python/Haskell. (A helper node for comprehension). Condition is a single condition"
  args: position, target, generator
  optargs: condition
  sexp: [target, generator, [_condition, condition]]
  children: target, generator, condition


FunctionDecorator:
  docstring: "Function Decorator"
  args: position, decorator, function
  sexp: ["function-decorator", decorator, function]
  children: decorator, function


Lambda:
  docstring: "A Lambda Function"
  args: position, arguments, value 
  sexp: ["lambda", arguments, value]
  children: arguments, value

